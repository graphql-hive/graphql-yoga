diff --git a/build/index.js b/build/index.js
index 5598580f37f909901fc77871395ffd24514561a1..d968de4a0f3b1ee39141ed47011d8011d5d9fa74 100644
--- a/build/index.js
+++ b/build/index.js
@@ -81,35 +81,15 @@ class LeakDetector {
     value = null;
   }
   async isLeaking() {
-    this._runGarbageCollector();
+    (0, _v().setFlagsFromString)('--allow-natives-syntax');
 
     // wait some ticks to allow GC to run properly, see https://github.com/nodejs/node/issues/34636#issuecomment-669366235
     for (let i = 0; i < 10; i++) {
+      eval('%CollectGarbage(true)');
       await tick();
     }
-    if (this._isReferenceBeingHeld) {
-      // triggering a heap snapshot is more aggressive than just `global.gc()`,
-      // but it's also quite slow, so only do it if we still think we're leaking.
-      // https://github.com/nodejs/node/pull/48510#issuecomment-1719289759
-      (0, _v().getHeapSnapshot)();
-      for (let i = 0; i < 10; i++) {
-        await tick();
-      }
-    }
     return this._isReferenceBeingHeld;
   }
-  _runGarbageCollector() {
-    const isGarbageCollectorHidden = globalThis.gc == null;
-
-    // GC is usually hidden, so we have to expose it before running.
-    (0, _v().setFlagsFromString)('--expose-gc');
-    (0, _vm().runInNewContext)('gc')();
-
-    // The GC was not initially exposed, so let's hide it again.
-    if (isGarbageCollectorHidden) {
-      (0, _v().setFlagsFromString)('--no-expose-gc');
-    }
-  }
 }
 exports["default"] = LeakDetector;
 })();
